%
\chapter{Creating video-summaries}
%
\section{Method}
%

%
\subsection{Segment Database}
%
The segment database contains all computed segments where each segment is a start and end frame, and which label it contains and the respective video.
%
\subsection{Candidate Factory}
%
The candidate factory generates all permutations of segments for which a select set, $L$, of labels is present. The results is called a candidate list. Based on the segment database it filters out
the segments for which a label $l$ in $L$ is not present. It then follows by computing the overlapping segments. Two segment are overlapping if they both originate from the same source video, do not share the same label, and $\text{max}(a, c) < \text{min}(b, d),$ where $a$ and $b$ are the start and end frame in the first segment, and $c$ and $d$ are the start and end frame in the second segment. If the segments overlap a new segment, $c$ is created where labels in $c$ is the union of labels in the two segments $x,y = \text{max}(a, c), \text{min}(b, d),$ where $x$ is the start frame in segment $c$ and $y$ is the end frame in segment $c$. if $y-x < 6$ segment $c$ is discarded, ie. the overlap is miniscule.\\
The candidate list is then sorted by number of labels in each candidate (the most relevant candidate is usually the ones where multiple labels overlap). We then get the first twenty different videos and feed these to a segment score algorithm described in section \ref{sec:segment_score}.
%
\subsection{Segment Score}\label{sec:segment_score}
%
% Remember to mention that segments chosen in part 3 are marked as used and can't be chosen again in that video.
%
The most fitting sub-parts of the video are found and scored based on how well they fulfill the label requirements we have constructed for the segment in question as well as how well they match the time span we are looking to fill. Each aspect is encapsulated in each their seperate fulfilment ratio, which are then later combined into a final score.
%
% Noter fra Kim: Alt for lang sætning
%
%
\subsubsection{Label fulfilment}
%
For each video in the candidate group we analyse each frame in regards to the labels present (or not present) in it. From this we generate a graph representing how well each frame throughout the video fulfills the label requirements we have for the segment to be chosen. Let $L_{x}$ be the set of labels we would like to be present in the segment, $n$ be the number of labels in $L_{x}$, $L_{y}$ be the set of labels which we require to be present, and $L_{z}$ be the set of labels which are forbidden to be present. Also let $f_{l}$ and $f_{n}$ be the set of requested labels present in frame $f$, and the number of requested labels present in frame $f$, respectively, where $f$ is a frame in the video. The requirement fulfilment-ratio for each frame is defined like this:\\
%
\begin{equation}
R(f) = \frac{f_{n}}{n} \cdot Y(f) \cdot Z(f)
\end{equation} 
%
, where\\
%
\begin{equation}
Y(f) =
\begin{cases}
0 & \text{, if} f_{l} \cap L_{y} \neq L_{y}\\
1 &  \text{, otherwise}
\end{cases}
\end{equation} 
%
, and\\
%
\begin{equation}
Z(f) =
\begin{cases}
0 & \text{, if} f_{l} \cap L_{z} \neq Ø\\
1 &  \text{, otherwise}
\end{cases}
\end{equation} 
%
\\
%
Effectively this means that a frame will receive a fulfilment-ratio of 0 percent if it does not contain a required label or if it contains a forbidden one, and the ratio of the number of requested labels it contains, otherwise.\\
%
With this fulfillment ratios across the entire span of the video we now have a tool of measure to identify the parts of it, that best fit the label requirements.
%
\subsubsection{Time span fulfilment}
%
The other aspect used to determine the score of a sub-part of a video is how well it fits within the time span we are looking to fill. A minimum- and maximum- length defines the time span, that we want the final segment to cover. Let $T_{min}$ and $T_{max}$ be the the minimum- and maximum- length, respectively, and let $l$ be the length of the sub-part in frames. The time span fulfilment ratio is then defined as:\\
%
\begin{equation}
\tau(l) =
\begin{cases}
1 & \text{, if } T_{max} = T_{min}\\
\frac{l-T_{min}}{T_{max}-T_{min}} &  \text{, otherwise}
\end{cases}
\end{equation} 
%
\\
%
A sub-part of minimum length will thus have time span fulfilment ratio of zero, while one of maximum length will have a ratio of one. 
%
\subsubsection{The score}
%
The score for a sub-part is based on how well it fulfils the label- as well as the time span-requirement. A ratio, $\alpha$, determines how the two are weighted against each other. Let $R$ be a set of the label fulfilment ratios for each frame in the video, define in [FORMULA:REF]. Also, for each possible sub-part (that does not exceed the maximum length defined in the time span requirement), let $v$ be the frame number where the sub-part begins, $w$ be the frame number where it ends, and $l$ be the length of it in frames. The score for the sub-part is then defined as:\\
%
\begin{equation}
S(v,w) =(1-\alpha) \cdot \sum_{i=v}^{w} \frac{R(i)}{l} + \alpha \cdot \tau(l)
\end{equation}
%
% Kim var forvirret over at L_{i} (nu omdøbt til R(i)) ikke hed det samme som i den tidligere formel. Check hele denne formel igen og hver sikker på at den giver mening.
%
% Noter fra Kim: Argumenter for formlen. Hvorfor virker den?
%
%
\\
%
The score is thus determined by the average label fulfilment rate in the sub-part, weighted against the time span it covers.
%
\subsection{Choosing a Segment}
%
The segment score algorithm described in section \ref{sec:segment_score} returns a number of candidate segments, each with an assigned score. A score sum, $S$ is computed:
\[
S = \sum{\text{score}(s)^2 \text{ for } s \text{ in candidates if } s > 0}.
\]
%
% Noter fra Kim: Sum over hvad?
%
A multiplier, $m$ is computed as
\[
m = \text{min}(10^5, \text{max}(10^5, X)), X = \frac{s}{S}^{-1},
\] % multiplier = min(1e5, max(1e5, 1 / (min_score / score_sum)))
%
% Noter fra Kim: Argument for dette (formlen?)
%
where $s$ is the smalles score of all candidates. This ensures that the probability score explained below is atleast 1.\\
A probability score, $P$, is then computed for each candidate 
\[
P = m \frac{s^2}{S} \text{ for } s \text{ in candidates if } s > 0.
\] % probability_score = multiplier * candidate.get('score')**2 / score_sum
%
The final candidate is then picked with probability $P$.
%Each candidate is then replicated $P$ times, ie. if candidate $a$ has a probability score of 4 and candidate $b$ has a probability score of 2 then the list of candidates is expanded to $C = [a,a,a,a,b,b]$. A final candidate, $c$, is selected at random in $C$.\\
%
% Noter fra Kim: Hvorfor ikke bare skrive at i sampler med sandsynlighed P? (for implementationsnært)
%
% This method has a minor rounding error which is roughly the decimal fraction of $P$ divided by the magnitude of $P$, which is in the order of $100\frac{1}{10^5} = 0.001\%$. IS IT NOW?????
%
% Noter fra Kim: ???
%
%
\subsection{Recipe}
%
% recipies - simple approach. no immediate feedback. kinda skipped lit. study on this one. universal recipe. 2 permutations on each dataset (different alpha_span value), and added some required labels 
% recipe structure: list of ingredients (labels, min/max span, interval, span alpha, required/forbidden labels)
A recipe is a list of ingredients in a specific order, much like a cooking recipe. Each ingredient is described by
\begin{itemize}
\item labels - labels present in a segment has a positive impact on the segment score
\item min. span - segments should be no shorter than this
\item max. span - segments should be no longer than this
\item interval - [LAUGE]
\item span alpha - weighing of labels vs. segment length
\item required labels - labels not present in a segment has a negative impact on the segment score
\item forbidden labels - labels present in a segment has a negative impact on the segment score
\end{itemize}
Unless otherwise noted we did 2 permutations on each dataset, each with a varying span alpha, $0.5$ and $0.25$.
%
% Noter fra Lauge: Lad os rykke de specifikke test valg til Test afsnittet.
%
%
\subsubsection{Random Labels}
% 
Our baseline recipe in its purest form selects random labels to feed the candidate factory, but in order to avoid idiosyncrasies we have made some minor tweaks to this selection. We will for instance not choose to have both the night and the day label in the same segment as they are by definition mutually exclusive. The length of each segment is also selected at random such that it is at least 2 seconds long, and the maximum length is selected such that the complete videoclip is somewhere between 25-35 seconds. If $mil$ is the minimum length of a segment and $k=9$ then $mil=\text{random}(48,24k)$ in frames, ie. between 2 and 9 seconds. The maximum segment length is then $mal=\text{random}(mil+6, 2mil+6)$. $mil$ would average $\frac{2+9}{2}=5.5$ seconds hence $mal$ would average $\frac{5.5+0.25+11+0.25}{2}=8.5$ seconds, and the total clip length, with 5 segments, then averages around $5\frac{5.5+8.5}{2}=35$ seconds.
% SPAN ALPHA?
%
\subsubsection{Designer}
% designer algo
We designed a recipe to be used on all three datasets. Ingredients outlined below:
\begin{itemize}
\item Overview shot, 3-5 seconds, no person in focus
\item Overview shot, 3-6 seconds, no person in focus
\item Crowd shot, 3-6 seconds, no person in focus
\item Crowd shot, 3-6 seconds, no person in focus
\item Person in focus shot, 4-8 seconds, not in a crowd
\item Person in focus shot, 4-8 seconds, not in a crowd
\item Overview shot, 3-5 seconds, no person in focus
\end{itemize}
%
During recipe tweaking we realized that the overview label and person in focus label often overlapped. To reduce the odds of having a person in focus on overview shots we put this label into the forbidden labels list (an overview can still have a person in focus not caught by our labeller).\\
Likewise there are typically two types of crowd shots. One has someone in focus, and the other one has not. We wanted the last type.
% Ingredient(labels=['is_overview'], min_span=72, max_span=120, forbidden_labels=['has_person_in_focus'], span_alpha=span_alpha),
% Ingredient(labels=['is_overview'], min_span=72, max_span=144, forbidden_labels=['has_person_in_focus'], span_alpha=span_alpha),
% Ingredient(labels=['is_in_crowd'], min_span=72, max_span=144, forbidden_labels=['has_person_in_focus'], span_alpha=span_alpha),
% Ingredient(labels=['is_in_crowd'], min_span=72, max_span=144, forbidden_labels=['has_person_in_focus'], span_alpha=span_alpha),
% Ingredient(labels=['has_person_in_focus'], min_span=96, max_span=184, required_labels=['has_person_in_focus'], forbidden_labels=['is_in_crowd'], span_alpha=span_alpha),
% Ingredient(labels=['has_person_in_focus'], min_span=96, max_span=184, required_labels=['has_person_in_focus'], forbidden_labels=['is_in_crowd'], span_alpha=span_alpha),
% Ingredient(labels=['is_overview'], min_span=72, max_span=144, forbidden_labels=['has_person_in_focus'], span_alpha=span_alpha)
